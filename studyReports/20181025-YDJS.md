# 2018-10-25 YOU DON'T KNOW JS

> 仅是YDJS这一系列的读书笔记，[想看原文戳此处](https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN)

## 你不懂JS：入门与进阶

1. `NaN`既不大于其他值，也不小于其他值，更不等于它本身。
2. ==和===的使用
    * 比较的两个值之一可能是true或false值，避免==而使用===。
    * 比较的两个值之一可能是这些具体的值（0，""，或[] —— 空数组），避免==而使用===。
    * **在所有其他情况下**，使用==是安全的，可以简化代码、改善可读性。
3. 关于this如何被设置有四个规则：
    * foo()：非strict模式中，将this设置为全局对象；在strict模式中，this将会是undefined。
    * obj1.foo()：将this设置为对象obj1。
    * foo.call(obj2)：将this设置为对象obj2。
    * new foo()：将this设置为一个新的空对象。

------

## 你不懂JS：作用域与闭包

1. 几个概念：
    1. 引擎：负责从始至终的编译和执行我们的 JavaScript 程序。
    2. 编译器：处理所有的解析和代码生成的重活儿（词法分析->解析->代码生成）。
    3. 作用域：收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。
2. 作用域查询方式
    * **LHS（左手边）**：向这个变量赋值。
        > 可以通过`=`操作符发生，也可以通过向函数参数传递（赋予）参数值发生
        > strict模式下，未被定义的变量将抛出`ReferenceError`
        > 若变量被找到，但是做了一些这个值不可能做到的事，将抛出`TypeError`
    * **RHS（右手边）**：取得它的值。
        > 未被满足的 RHS 引用会导致 `ReferenceError`被抛出
3. 词法作用域(js 使用的作用域，还有一种动态作用域)
   > 由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。
   * “欺骗”词法作用域的两种方式
        * eval(..) ：通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。
        * with：实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。
        * 缺点：压制了引擎在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是无效的。代码将会运行的更慢。**不要使用它们**。
  
